## 监听数据变化的原理

监听数据变化其实非常简单， JavaScript 在 ES5 中就提供了属性描述符的支持，我们通过对某个对象的某些属性定义 `getter` 和 `setter` 在其中我们可以新增自己的监听逻辑。如果还不了解属性描述符的请访问 [MDN - `Object.defineProperty`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 查看详情。

简单写一个监听对象属性访问和修改的方法，可以如下所示：

```js
/**
 * 使得一个对象的某个属性可观测
 *
 * @param {object} obj 目标对象
 * @param {string} key 目标属性
 * @param {any} val 目标对象指定属性的初始值
 */
function makeReactive(obj, key, val) {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: true,
    get: function reactiveGetter() {
      console.log("get value of " + key);
      return val;
    },
    set: function reactiveSetter(newVal) {
      console.log(`set value of ${key} the old: ${val} , new: ${newVal}`);
      val = newVal;
    }
  });
}
```

这时候如果我们有一个对象，我们想要在其属性访问和修改时得到通知，则只用获取每个属性，调用上面的定义好的方法即可。

```js
// 一个测试对象
const zs = { name: "zs", age: new Date().getFullYear() - 1991 };
// 获取所有可枚举键值对 加入属性可观察的的 getter 和 setter
Object.keys(zs).forEach(key => makeReactive(zs, key, zs[key]));
```

可以在下方demo中操作体验。

<p class="codepen" data-height="265" data-theme-id="default" data-default-tab="js,result" data-user="cdswyda" data-slug-hash="zYxEZXw" data-preview="true" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="mini-vue-makeReactive-1">
  <span>See the Pen <a href="https://codepen.io/cdswyda/pen/zYxEZXw">
  mini-vue-makeReactive-1</a> by Douglas Chen (<a href="https://codepen.io/cdswyda">@cdswyda</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

## 数组怎么办

以上简单演示了，针对对象属性值变更的监测，那么数组也是使用频率极高的结构，数组上如何处理呢。

因为 Vue 本身未提供数组以下两种形式的监听： 通过数组下标设置数组某一项、修改数组长度。 有不少文章将且解读为 `Object.defineProperty` 不支持对数组进行检测。

事实到底如何，我们一试便知：

```js
// 一个测试数组
var arr = [1, 2, 3];

arr.forEach((val, index) => {
  makeReactive(arr, index + "", val);
});

// 看看这一句 能不能正常输出 get 和 set 即可
arr[0]++;
```

照例，看以下 demo：

<p class="codepen" data-height="265" data-theme-id="light" data-default-tab="js,result" data-user="cdswyda" data-slug-hash="KKwXmoW" data-preview="true" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="mini-vue-makeReactive-2">
  <span>See the Pen <a href="https://codepen.io/cdswyda/pen/KKwXmoW">
  mini-vue-makeReactive-2</a> by Douglas Chen (<a href="https://codepen.io/cdswyda">@cdswyda</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

JavaScript 中一切皆对象，数组实质上也是一个对象，不信自行去验证 `Array instanceof Object` 的结果是啥。因此并没有 `Object.defineProperty` 不支持数组操作这一说。

那么，为什么又会有很多数组不支持的说法呢？其实结合我们在js中常规使用数组的方式和上面的观测方法很容易得出为什么。

在 js 中我们使用数组基本不会 new 一个定长数组，然后通过下标逐个赋初始值，基本都是直接给空数组，或直接将元素放入数组完成初始化。后续变更则是通过数组上的方法来对数组做修改。

而上面对数组的观测也有很明显的弊端，它是需要对每个数组的下标进行观测，如果最初是一个空数组，`forEach` 遍历不到任何元素的存在，相当与响应式的观测根本未执行。

那么问题就来了，**数组怎么办？**

不妨从使用者的角度来看，js 中内置对象中，数组上的方法是最多的，很多方法是修改数组自身的，其使用也最为频繁，那么如果能在调用数组这些方法时获取到变化自然也就能达到观测的目的了。

简单整理下，修改数组自身内容的方法有 `push`,`pop`,`shift`,`unshift`,`splice`,`sort`,`reverse` 这七个，只用对这7个做处理即可。

```js

```

## 进一步完善对数据的监听

以上很简陋地实现了对数据修改和访问的监听，下面我们来完善一下，主要包含以下几个部分：

1. 属性的递归处理，如果某个属性值是对象，则需要对此对象下也进行处理。
2. 避免重复 `makeReactive` 。
3. 封装优化代码。

首先，我们需要监听某个对象时，应该直接传入对象即可，遍历对象所有属性再调用处理方法的逻辑不应该由外部完成。对此，我们提供一个统一入口。

```js
class Observer {
  constructor(value) {
    this.value = value;

    // 加一个不可枚举的 ob 属性， value 即为当前可观测示例。
    // 后续可用此属性来判断是否应处理过了
    Object.defineProperty(value, "__ob__", {
      value: this,
      enumerable: false
    });

    if (Array.isArray(value)) {
      // 数组的情况下, 考虑性能，不是监听数组中的每个下标
      // 取而代之的是为原数组上可修改数组本身的那些方法打补丁
      //
    } else {
      this.walk(value);
    }
  }

  walk(/** @type object */ obj) {
    Object.keys(obj).forEach(key => {
      makeReactive(obj, key, obj[key]);
    });
  }
}

/**
 * 使得一个对象的某个属性可观测
 *
 * @param {object} obj 目标对象
 * @param {string} key 目标属性
 * @param {any} val 目标对象指定属性的初始值
 */
function makeReactive(obj, key, val) {
  // 如果是对象 则也需要进行处理
  if (typeof val === "object") {
    return new Observer(val);
  }

  // 此处先获取原来的属性描述符， 作用：
  // 如果数据对象原来有使用属性描述符定义过 getter 和 setter , 则我们在新增响应式监听时，不应该覆盖之前的定义。
  // 如果有则需调用原有定义，保障原逻辑的可用性
  const oldProperty = Object.getOwnPropertyDescriptor(obj, key);
  const getter = oldProperty && oldProperty.get;
  const setter = oldProperty && oldProperty.set;

  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: true,
    get: function reactiveGetter() {
      const v = getter ? getter.call(obj) : val;
      console.log("get value of " + key);
      return v;
    },
    set: function reactiveSetter(newVal) {
      const v = getter ? getter.call(obj) : val;

      // 值未变化就无需处理了
      if (newVal === v) return;
      console.log(`set value of ${key} the old: ${val} , new: ${newVal}`);
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
    }
  });
}
```
